\section{Graph recommender systems}\label{sec:graph-rec-sys}
One of the problems often encountered in recommender systems is the problem of sparsity in larger recommender systems.
Two different kinds of approaches are often used to combat this. 
The first is to use dimensionality reduction where the representation of users and items are converted into a more compact representation, which should capture the most important features that describe the user or item.
An example of this is the matrix factorization technique, where a matrix $U \times I$ is decomposed into the product of two matrices $U \times K $ and $ K \times I$ where $K$ is the number of features to capture.
These representations are able to capture meaningful information about the relations between users and items, even if users have rated different items, or items were rated by different users. 
The other approach used for the sparsity problem is the use of graph representations for the data.
When using graph representations for the data, graph-based methods are able to utilize the transitivity in the relations between the data points. 
This means that similarity can be found between users that are not directly connected, which can help alleviate the sparsity problem.
Graph representations are also able to preserve the local relations as they have the edges between them that show the local neighborhood and how closely connected the nodes are, compared to the dimensionality reduction approach where some of this local information is lost as a result of the feature extraction\cite{RecommenderHandbook2015}.
\\\\
A typical way to represent graphs in recommender systems is using bipartite graphs.
In a bipartite graph, there are two distinct sets of nodes.
One set of nodes is the users and the other set is the items.
The edges in the bipartite graph connect the user and item nodes if the user has rated the item. 
The edge can have the rating as its weight if a rating is given.
An example of how a bipartite graph could look can be seen on \autoref{fig:bipartite-graph}.
\begin{figure}[h]
\begin{tikzpicture}[thick,
    every node/.style={draw,circle},
    fsnode/.style={fill=myblue},
    ssnode/.style={fill=mygreen},
    every fit/.style={ellipse,draw,inner sep=-2pt,text width=2cm},
    shorten >= 3pt,shorten <= 3pt
  ]
  
  % the vertices of U
  \begin{scope}[start chain=going below,node distance=7mm]
  \foreach \i in {u1,u2,u3}
    \node[fsnode,on chain] (f\i) [label=left: \i] {};
  \end{scope}
  
  % the vertices of I
  \begin{scope}[xshift=4cm,start chain=going below,node distance=7mm]
  \foreach \i in {i1,i2,i3,i4}
    \node[ssnode,on chain] (s\i) [label=right: \i] {};
  \end{scope}
  
  % the set U
  \node [myblue,fit=(fu1) (fu3),label=above:$U$] {};
  % the set I
  \node [mygreen,fit=(si1) (si4),label=above:$I$] {};
  
  % the edges
  \draw (fu1) -- (si1);
  \draw (fu1) -- (si4);
  \draw (fu2) -- (si1);
  \draw (fu2) -- (si3);
  \draw (fu3) -- (si3);
  \draw (fu3) -- (si2);
\end{tikzpicture}
\caption{Example of a bipartite graph}
\label{fig:bipartite-graph}
\end{figure}

As mentioned, with the use of graph representations, users and items not directly connected can influence each other.
There are two properties that are often explored for graph-based approaches when doing similarity measures, namely propagation and attenuation.
Propagation is done through propagating information along the edges of the graph, also using the weight of the edge to determine how much information is allowed to pass through.
Attenuation considers that nodes that are further away from each other in the graph should influence each other less.
This transitive association in graph-based approaches can be used in two ways to recommend items.
The relevance between a user \textit{u} and an item \textit{i} can be evaluated using the proximity of \textit{u} to the item \textit{i}, meaning that the items that are "closest" in the graph to \textit{u} will be recommended.
A similarity between a pair of users or items can also be found which can be expressed as a weight between them\cite{RecommenderHandbook2015}.

\subsection{Side-information in graphs}
With the structure of a graph, it is possible to extend it with side-information.
This can be done either with information about the interaction between user and an item by adding side-information to the edge between the two nodes, such that the edge $(u, i)$ that previously indicated an interaction between a user and an item is extended with side-information such as $(u, r, i)$, where $r$ is a rating that user $u$ has assigned to item $i$\cite{aggarwal2016recommender}. 
Additionally, side-information can be added to user or item nodes, which allows us to do constraints on the recommendations, similar to how contextual filtering works as described in \autoref{subsec:utilizingandobtainingcontext}.
For users, this side-information can be attributes such as their age, location or gender.
For a movie, it can be attributes such as actors, genre or budget.
Adding this side-information allows us to connect items through other nodes than just user nodes and vice-versa.


\input{sections/graphrecs/ngcf.tex}
